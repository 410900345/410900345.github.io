<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 视图控制器转场详解]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[最近在研究微信小程序的入场和出场动画所以对这块进行了调研，总结一些踩过的坑 一.model转场动画Present\Dismiss。12转场代理@protocol UIViewControllerTransitioningDelegate 1234567891011121314// 展示的动画- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;// 消失的动画- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;// 手势驱动的动画，手势驱动的实现- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;// 手势驱动的动画消失，手势驱动的实现- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;// 新的方法，操作性比较大- (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source NS_AVAILABLE_IOS(8_0); 二.UINavigationControllerDelegate，Pop 和 Push 的自定义动画。12345678910// 手势驱动- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController NS_AVAILABLE_IOS(7_0);// 转场动画- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC NS_AVAILABLE_IOS(7_0); 三.手势交互,主要类是UIPercentDrivenInteractiveTransition12345678910111213141516171819202122232425262728293031- (void)onPan:(UIPanGestureRecognizer *)pan &#123; CGPoint translation = [pan translationInView:pan.view.superview]; switch (pan.state) &#123; case UIGestureRecognizerStateBegan: &#123; // 开始驱动动画 self.interactionInProgress = YES; [self.animationViewController.navigationController popViewControllerAnimated:YES]; &#125; break; case UIGestureRecognizerStateChanged: &#123; CGFloat percent = translation.x / [UIScreen mainScreen].bounds.size.width; percent = MIN(1.0, MAX(0.0, percent)); [self updateInteractiveTransition:percent]; // see: https://github.com/ColinEberhardt/VCTransitionsLibrary/issues/4 if (percent &gt;= 1.0) &#123; percent = 0.99; &#125; self.shouldComplete = percent &gt; 0.5; &#125; break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: &#123; self.interactionInProgress = NO; if (pan.state == UIGestureRecognizerStateCancelled || !self.shouldComplete) &#123; [self cancelInteractiveTransition]; &#125; else &#123; [self finishInteractiveTransition]; &#125; &#125; break; default: break; &#125;&#125; 四.动画实现类，UIViewControllerAnimatedTransitioning12345// 动画时间-(NSTimeInterval)transitionDuration:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext; // 转场动画效果实现的位置-(void)animateTransition:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext; 。 具体代码 123456789101112131415161718192021222324252627282930313233- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; return 0.8f;&#125;- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; // 1. Get controllers from transition context UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; // 2. Set init frame for toVC CGRect screenBounds = [[UIScreen mainScreen] bounds]; CGRect finalFrame = [transitionContext finalFrameForViewController:toVC]; toVC.view.frame = CGRectOffset(finalFrame, 0, screenBounds.size.height); // 3. Add toVC's view to containerView UIView *containerView = [transitionContext containerView]; [containerView addSubview:toVC.view]; // 4. Do animate now NSTimeInterval duration = [self transitionDuration:transitionContext]; [UIView animateWithDuration:duration delay:0.0 usingSpringWithDamping:0.6 initialSpringVelocity:0.0 options:UIViewAnimationOptionCurveLinear animations:^&#123; toVC.view.frame = finalFrame; &#125; completion:^(BOOL finished) &#123; // 5. Tell context that we completed. [transitionContext completeTransition:YES]; &#125;];&#125; 一些注意:1.在动画结束后我们必须向context报告VC切换完成，是否成功（在这里的动画切换中，没有失败的可能性，因此直接pass一个YES过去）。系统在接收到这个消息后，将对VC状态进行维护。2.尽量使用系统提供的方法finalFrameForViewController来确定位置，由于 iOS11和iOS10等系统对转场动画结束的处理方式不一致，在手势驱动结束和取消的时候进行动画的还原否则会出现莫名其妙的 bug，例如黑屏， 1234567-(CGRect)initialFrameForViewController:(UIViewController *)vc; 某个VC的初始位置，可以用来做动画的计算。-(CGRect)finalFrameForViewController:(UIViewController *)vc; 与上面的方法对应，得到切换结束时某个VC应在的frame。-(UIView *)containerView; VC切换所发生的view容器，开发者应该将切出的view移除，将切入的view加入到该view容器中。-(UIViewController *)viewControllerForKey:(NSString *)key; 提供一个key，返回对应的VC。现在的SDK中key的选择只有UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两种，分别表示将要切出和切入的VC。 问题： 1.目前发现在iOS9.0模拟器表现不正确，目前最新已经是 ios12Beta，未找到真机测试，测试了几个比较好，都有这个问题，在这里推荐一个比较好的库VCTransitionsLibrary 2.还有就是在手势滑动结束的时候，动画会闪动,然后变成正常的位置，转场动画尽量添加到containerView，进行否则会出现莫名其妙的的 bug,使用下面代码，尝试去解决 123456789101112131415161718192021222324252627282930313233343536/** 手动接管 取消流程,在10.3.2 plus上取消时,位置不正确 cancelInteractiveTransition */- (void)continueAction &#123; if (!_link) &#123; _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(UIChange)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes]; &#125;&#125;- (void)stopCADisplayLink &#123; [_link setPaused:YES]; [_link removeFromRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes]; [_link invalidate]; _link = nil;&#125;- (void)UIChange&#123; CGFloat timeDistance = 2.0/60; if (_percent &gt; 0.5) &#123; _percent += timeDistance; &#125; else &#123; _percent -= timeDistance; &#125; [self updateInteractiveTransition:_percent]; if (_percent &gt;= 1.0) &#123; [self finishInteractiveTransition]; [self stopCADisplayLink]; &#125; if (_percent &lt;= 0.0) &#123; [self cancelInteractiveTransition]; [self stopCADisplayLink]; &#125;&#125; 手势驱动结束滑动之后，剩余距离的速度1234567/** 手势最后的运动速度 @return 速度值 */- (CGFloat)completionSpeed &#123; return 1 - self.percentComplete;&#125; 里面很多没有整理demo 参考链接1 onecat 生命周期 唐巧大大 参考地址]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新mac 环境配置]]></title>
    <url>%2F2018%2F05%2F04%2F%E6%96%B0mac%2Cruby%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ruby 环境配置rvmRVM : Ruby Version Manager, Ruby版本管理器,包括Ruby的版本管理和Gem库管理(gemset). 123$ curl -L get.rvm.io | bash -s stable# 或者$ bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer) 配置环境变量~/.bash_profile 配置淘宝镜像地址 1https://ruby-china.org/wiki/rvm-guide]]></content>
      <categories>
        <category>ios,技巧,tools,js,原理,iphone,小技巧&lt;!--选一个--&gt;</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RSS 订阅一切]]></title>
    <url>%2F2018%2F04%2F11%2Frss%E8%AE%A2%E9%98%85%E4%B8%80%E5%88%87%2F</url>
    <content type="text"><![CDATA[本人使用 RSS 订阅信息流,查看相应的文章,但是由于一些 Blog或者简书等内容不支持 RSS, 尝试自己生成 feed 链接. 具体步骤 RSS 订阅软件inoreader特点是无订阅上限,缺点是需要翻墙使用. Feed43可以为静态网站制作RSS. 首先输入页面地址：http://love.appinn.com，点击 Reload，就能看到页面代码了。替换成 123&lt;div class="n1"&gt;&#123;*&#125;&lt;a href="\&#123;\%\&#125;" class="anchorLink" onclick=&#123;*&#125;&gt;\&#123;\%\&#125;&lt;br /&gt;&lt;span&gt;\&#123;\%\&#125;&lt;/span&gt;&lt;/a&gt;&#123;*&#125;&lt;/div&gt;&#123;*&#125; 解释 \{\%\}是替换我们要查看的内容比如 title, 时间,内容等,下一步会用到,按照模板进行替换就可以 {*}是替换任意代码的通配符,每行末尾和空白行也加上{*} Define extraction rules 我们输入,我们在下面输入,会按照内容继续解析 再后面经过简单的设置，注意把第二个和第三个参数连起来： *自制版本的 Feed 就成功了,会输出我们的内容 安装RSS Subscription Extension插件在Chrome中使用RSS服务，可以安装一个RSS Subscription Extension的插件，快捷添加 RSS 订阅源到指定的订阅服务. 点击图标进入RSS Subscription Extension 点击管理,添加相应的订阅源 在RSS订阅选项设置页面中点击添加，在编辑供稿阅读器中加入说明和网址http://www.inoreader.com/?add_feed=%s。 其他的订阅软件一览免费版最多可以订阅100个RSS源、10个微信公众号。 替换模板，删掉里面的\ github.io 等 blog,根据实际博客样式情况,进行替换， 12345678910&lt;/a&gt;&#123;*&#125;&#123;*&#125;&lt;/h1&gt;&#123;*&#125;&#123;*&#125;&lt;div class="post-meta"&gt;&#123;*&#125;&lt;time &#123;*&#125;content="\&#123;\%\&#125;" &gt;&#123;*&#125;&#123;*&#125;&lt;/time&gt;&#123;*&#125;&lt;/div&gt;&#123;*&#125; 解析完后内容 123456789\&#123;\%1\&#125; = \&#123;\%2\&#125; = http://xxx.html/\&#123;\%3\&#125; = \&#123;\%4\&#125; = xxx\&#123;\%5\&#125; = \&#123;\%6\&#125; = \&#123;\%7\&#125; = \&#123;\%8\&#125; = 2017-09-24\&#123;\%9\&#125; = 09-24 取出的内容 123title 为 \&#123;\%4\&#125; \&#123;\%8\&#125;link 为 \&#123;\%2\&#125;titlecontent 为 \&#123;\%4\&#125; 简书等内容的模板 12345678910&lt;div class="content"&gt;&#123;*&#125;&lt;div class="author"&gt;&#123;*&#125;&#123;*&#125; &lt;span class="time" data-shared-at="\&#123;\%\&#125;"&gt;&lt;/span&gt;&#123;*&#125;&lt;/div&gt;&#123;*&#125;&lt;/div&gt;&#123;*&#125;&lt;a class="title" target="_blank" href="\&#123;\%\&#125;"&gt;\&#123;\%\&#125;&lt;/a&gt;&#123;*&#125;&lt;p class="abstract"&gt;&#123;*&#125;\&#123;\%\&#125;&lt;/p&gt;&#123;*&#125;&lt;div class="meta"&gt;&#123;*&#125; 解析完后内容 12345\&#123;\%1\&#125; = xxx\&#123;\%2\&#125; = 2017-08-22T22:06:41+08:00\&#123;\%3\&#125; = https://www.jianshu.com/p/xxx\&#123;\%4\&#125; = ixxx\&#123;\%5\&#125; = xxx 取出的内容 123title 为 \&#123;\%4\&#125; \&#123;\%2\&#125;link 为 \&#123;\%3\&#125;titlecontent 为 \&#123;\%5\&#125; 掘金个人下面的专栏模板 1&lt;div data-src="\&#123;\%\&#125;" &#123;*&#125;&gt;\&#123;\%\&#125;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;&lt;span class="date" data-v-36108f72&gt;\&#123;\%\&#125;&lt;/span&gt;&lt;/div&gt;&lt;!----&gt;&lt;div class="row abstract-row" data-v-36108f72&gt;&lt;a href="\&#123;\%\&#125;" target="_blank" rel="" st:name="title" class="title" data-v-36108f72&gt;\&#123;\%\&#125;&lt;/a&gt;&lt;a href="\&#123;\%\&#125;" target="_blank" rel="" st:name="abstract" class="abstract" data-v-36108f72&gt;\&#123;\%\&#125;&lt;/a&gt; 解析完后内容 1234567\&#123;\%1\&#125; = xxx\&#123;\%2\&#125; = xxx\&#123;\%3\&#125; = 4月前\&#123;\%4\&#125; = https://juejin.im/post/xxx\&#123;\%5\&#125; = xxx）\&#123;\%6\&#125; = https://juejin.im/post/xxx\&#123;\%7\&#125; = 123title 为 \&#123;\%5\&#125; \&#123;\%3\&#125;link 为 \&#123;\%4\&#125;titlecontent 为 \&#123;\%7\&#125; 微信公众号订阅传送门 手把手教你制作 RSS 源 为没有 Feed 的网页生成 RSS 格式 rss_for_everything 安装RSS Subscription Extension插件]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017总结]]></title>
    <url>%2F2018%2F04%2F11%2F2017%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2017年1.微信小程序只是看了文档和注册了,并没有实现相应的 demo 项目. 2.减肥的工作没有实现. 3.ppt分享没有实现. 2018年1.微信小程序现相应的 demo 项目,写过毕竟要更加深刻理解,趣厨房 2.减肥的工作继续. 3.分享没有实现,继续努力. 4.用 swift 和 rac 实现 demo. 5.继续研究相关的题目,总结相关的知识点,深挖原理性东西,保持竞争力.llvm 方向的研究 6.LeetCode 相关内容 好的内容https://lrh1993.gitbooks.io/android_interview_guide/content/https://github.com/ming1016/study 书单《程序员的自我修养》 《iOS 应用逆向工程》 《macOS软件安全与逆向分析》 深入解析Mac OS X &amp; iOS操作系统： 《Swifter - Swift 必备 Tips》]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[空间不足,清理Mac空间]]></title>
    <url>%2F2018%2F04%2F10%2F%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%2C%E6%B8%85%E7%90%86Mac%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[笔者使用的MacBook,空间只有128G,由于安装了Xcode和 Android studio 经常由于空间不足,导致项目无法进行编译.推荐使用下面软件进行整理. OmniDiskSweeper查看空间占用并清理 CleanMyMac 3.9.4强大的mac系统清理工具 针对性的大文件删除 ~/Library/Developer/Xcode/DerivedData/ Xcode编译时的文件缓存,build的信息等都会保存在这里,删除后在下次打开项目编译的时候将会重新生成,可以全部删掉. ~/Library/Developer/Xcode/iOS DeviceSupport/ Xcode支持的真机测试对应的版本文件,真机调试的时候会自动关联生成,删掉比较老的版本文件,低于11.3版本的文件夹. ~/Library/Developer/Xcode/Archives/ Xcode打包的文件dSYM等内容,保留上线版本,如果使用第三方的 bug 管理工具如 Bugly 会自动上传,可以根据情况删掉文件. ~/Library/Developer/CoreSimulator/Devices/ 模拟器上的APP数据,重置模拟器会删掉相应的文件,可以按时间进行排序,然后删掉比较老的文件,或者直接全部删掉,编译运行会再次重新安装 APP. 参考地址]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[更新next主题]]></title>
    <url>%2F2018%2F01%2F10%2F%E6%9B%B4%E6%96%B0-next-%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.增加404腾讯公益配置按照配置说明，新建 404.html 文件，放在主题 next 的 source 文件夹根目录下，配置文件 _config.yml 中信息如下： 1234menu: home: / || home about: /about/ || user commonweal: /404.html || heartbeat 2.“Updates were rejected because the tag already exists” when attempting to push in SourceTreetag 已经存在，使用下面命令进行提交，覆盖,一次获取所有新增的标签，进行覆盖 1git pull --tags 3.Github 上怎样把新 commits 使用在自己的 fork 上首先要先确定一下是否建立了主repo的远程源： 1git remote -v 如果里面只能看到你自己的两个源(fetch 和 push)，那就需要添加主repo的源：URL为原来repo的源 12git remote add upstream URLgit remote -v 然后你就能看到upstream了。 如果想与主repo合并： 12git fetch upstreamgit merge upstream/master 4.Mac如何关闭指定port查询 port 对应的 pid 1lsof -i: port 关闭 pid 1sudo kill -9 pid 参考地址 next stackoverflow Github 上怎样把新 commits 使用在自己的 fork 上 Git 基础]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不用信用卡创建美国appstore id注册]]></title>
    <url>%2F2017%2F11%2F14%2F%E7%BE%8E%E5%9B%BDappid%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[不用信用卡创建美国appstore id注册方法一 在手机上找到appstore 选择帐号退出. 搜素一个免费的应用wingy(翻墙)点击点击下载,自动跳转到美国商店. 在弹出式菜单中，点按创建新帐户,地区选择美国.另外一个好用的翻墙软件Potatso 接下来填写邮箱、密码、提示问题及答案、救援邮箱以及生日信息，继续点击 「Next.(不要用qq邮箱,可以用163邮箱) 接下来，一般我们是没有拥有美国地址的信用卡，所以选择「None」然后点击「Next」. 可以按书写地址(可直接填写下方我给出的信息) 方法二用PC去(可能手机也可以，刚没有试)， icloud注册账号，地区任意选择，QQ邮箱也没有问题。使用iPhone（未登录APP Store）下载一个免费应用，这时候使用iCloud ID登录，就会出现不需要信用卡的选项。 参考地址知乎]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[googgle cloud 搭建ssr 免费使用一年]]></title>
    <url>%2F2017%2F10%2F26%2Fgooggle-cloud-%E6%90%AD%E5%BB%BAssr%2F</url>
    <content type="text"><![CDATA[由于最近翻墙困难,各种免费ss帐号也不靠谱,所以选择google cloud自己搭建梯子! 一.准备条件 能访问google cloud,和创建google帐号. 有一张Visa、Master等美元支付信用卡（会冻结$1),按照要求填写信用卡信息,本人交行visa信用卡,直接成功,(注册成功后风控人员还打了电话回访) 二.具体步骤1.创建实例点击菜单产品与服务-&gt;计算引擎-&gt;VM实例-&gt;创建实例, 名称随意,地区选择区建议选亚洲的（asia-east台湾、asia-northeast日本、asia-southeast新加坡） 机器类型把默认的3.75GB主机换成微型0.6GB的，搭建SS足够了，这样可以把主机月使用费降低 映像建议选择Ubuntu 16.04.(CentOS 7也可以，但是我用了之后有问题，后文会提到） 防火墙：允许HTTP流量，允许HTTPS流量 vm创建完成后，进入控制台-网络-外部IP地址，将vm分配的外部地址由临时改为静态,需要一个固定地址ip为ss访问 2.进入控制台-vpc网络-防火墙规则，允许tcp所有端口 创建防火墙规则（未提及的全部默认）：流量方向入站、来源ip地址0.0.0.0/0、协议和端口全部允许,允许协议和端口填tcp:1-65535; udp:1-65535 流量方向出站、来源ip地址0.0.0.0/0、协议和端口全部允许（注意要创建两次防火墙规则，一次出站，一次入站）,允许协议和端口填tcp:1-65535; udp:1-65535 3.配置SS以及BBR进入控制台-计算引擎-VM实例，点击连接-SSH，在浏览器中可以直接打开控制台，并且支持复制粘贴 首先获得root权限，在SSH里输入 1sudo -i 下面安装Google的开源TCP BBR拥塞控制算法秋水逸冰的BBR一键安装脚本地址三行命令 123wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 可以使用下面命令校验 1sysctl net.ipv4.tcp_available_congestion_control 出现 1net.ipv4.tcp_available_congestion_control = bbr cubic reno 类似含有bbr字样即成功。 安装ShadowSocks脚本,秋水逸冰的四合一一键安装脚本,三行命令 123wget –no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 选择SS版本（我这里选择的第二个，SSR，目前安全性最高），依次输入端口号和密码等,等待安装结束重启 4.配置SS和修改将ShadowSocks服务加入自动重启,很重要! 1sudo vim /etc/rc.local 输入下面命令exit 0上面 123sleep 10/usr/bin/ssserver /etc/init.d/shadowsocks-r startexit 0 输入完成后，ESC键后输入:wq，保存退出,SSH中输入reboot重启，如果SSR服务自动启动表明成功, 建立完成后,家里可以使用.单位链接不上?有知道的能否解答一下? 站长工具 &gt; Ping检测 ShadowsocksX-NG官方地址 参考链接1 参考链接2]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[修改ios测试打包 icon]]></title>
    <url>%2F2017%2F09%2F08%2F%E4%BF%AE%E6%94%B9ios%E6%B5%8B%E8%AF%95%E6%89%93%E5%8C%85-icon%2F</url>
    <content type="text"><![CDATA[为了方便测试人,测试人员可以直接从icon上看到当前测试的版本和版本的发布时间,方便,同时在预上线和生成环境上不执行这个脚本,不显示 icon 信息等内容!原理是在编译完成之后编辑编译后文件里面的appicon 内容! 最终的效果 1.安装环境12brew install imagemagickbrew install ghostscript ImageMagick为在命令行下操作图片提供了很多的功能，而ghostscript则是为了在icon上写的字体好看 2.配置脚本在Target的Build Phases中添加一个Run Script的Build Phase 脚本地址 参考链接1 参考链接2 参考链接3]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell常用]]></title>
    <url>%2F2017%2F09%2F08%2Fshell%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.shell 中判断字符串为空的正确方法 12345678#!/bin/shSTRING=if [ -z "$STRING" ]; then echo "STRING is empty" fiif [ -n "$STRING" ]; then echo "STRING is not empty" fi]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[auto layout VFL规则]]></title>
    <url>%2F2017%2F09%2F01%2Fauto-layout-VFL%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[在使用 Auto Layout 时，首先需要将视图的 setTranslatesAutoresizingMaskIntoConstraints属性设置为 NO。这个属性默认为 YES。当它为 YES 时，运行时系统会自动将 Autoresizing Mask 转换为 Auto Layout 的约束，这些约束很有可能会和我们自己添加的产生冲突。 1.常用api1).NSLayoutConstraint API1234NSLayoutConstraint+ (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)optsmetrics:(NSDictionary *)metricsviews:(NSDictionary *)views; 参数介绍: format:此参数为你的vfl语句，比如:@”H:|-[button]-|” opts:枚举参数，默认写0，具体跟据你所实现的需求去选择你想要的枚举 metrics:这里是一个字典，当在format中使用了动态数据比如上现这句:@”H:|-[button(==width)]-|”,表示这个button的宽度为width,那么这个参数去哪里找呢？就是在这个字典里面找到key对就的值，如果没有找到这个值，app就会crash. views:顾名思义，这是传所有你在vfl中使用到的view，那在上面这句例子中的应该怎么传呢？结果是这样的：NSDictionaryOfVariableBindings(button).如果你使用到了多个view，就可以这样NSDictionaryOfVariableBindings(button,button1,button3…),这个名字也要跟参数format中的一一对应，缺一不可. 2).+(instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;前三个和被约束的视图有关，后四个和他的父视图有关。这个方法连起来可以翻译如下：view1的某个属性（attr1）等于view2的某个属性（attr2）的值的多少倍（multiplier）加上某个常量（constant）。描述的是一个view与另外一个view的位置和大小约束关系。其中属性attribute有上、下、左、右、宽、高等，关系relation有小于等于、等于、大于等于。需要注意的是，小于等于 或 大于等于 优先会使用 等于 关系，如果 等于 不能满足，才会使用 小于 或 大于。例如设置一个 大于等于100 的关系，默认会是 100，当视图被拉伸时，100 无法被满足，尺寸才会变得更大。 如果是设置view自身的属性，不涉及到与其他view的位置约束关系。比如view自身的宽、高等约束时，方法constraintWithItem:的第四个参数view2（secondItem）应设为nil；且第五个参数attire（secondAttribute）应设为NSLayoutAttributeNotAnAttribute 。在设置宽和高这两个约束时，relatedBy参数使用的是 NSLayoutRelationGreaterThanOrEqual，而不是 NSLayoutRelationEqual。因为 Auto Layout 是相对布局，所以通常你不应该直接设置宽度和高度这种固定不变的值，除非你很确定视图的宽度或高度需要保持不变。 2.举个栗子1234NSArray *constraints1=[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-[button]-|" options:0 metrics:nil views:NSDictionaryOfVariableBindings(button)]; 说明H:”是表示这是水平方向上的约束， “|”是表示superView， “-“表示一个间隔空间，这个间隔如果是如superView之间的，那么就是20px,如果是两个同级别的view，比如@”[button]-[button1]”，那么这里表示的是8px. 1234NSArray *constraints2=[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-20-[button(==30)]" options:0 metrics:nil views:NSDictionaryOfVariableBindings(button)]; 说明V:”中代表这是垂直方向上的约束, “|-20-“这里的意思就是距离头部为20px，相当于y坐标为20。 后面的”[button(==30)]”，是指定这个button的高度为30px.y坐标固定 3.总结三：最后对格式的字符串作一个总结介绍 功能 表达式 水平方向 H: 垂直方向 V: Views [view] SuperView | 关系 &gt;=,==,&lt;= 空间,间隙 - 优先级 @value 参考地址链接：]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[andriod打包相关]]></title>
    <url>%2F2017%2F08%2F08%2Fandriod%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[简介http://localhost:8081/index.android.bundle?platform=android；当应用启动运行的时候，会自动拉取这个bundle文件，该文件里存放的是应用的全部逻辑代码，在目录中并不存在这个文件，事实上，这个地址只是一个请求地址，而非真正的静态资源文件，是通过包服务器packager通过动态分析index.android.js中的依赖，并对其进行合并得到的，而且该服务允许代码实时渲染。 具体步骤 1.生成一个签名密钥 1keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 最后它会生成一个叫做my-release-key.keystore的密钥库文件 2.找到路径/android/app/src/main，并在该目录下新建assets文件夹 3.在工程目录下将index.android.bundle下载并保存到assets资源文件夹中 1curl -k "http://localhost:8081/index.android.bundle" &gt; android/app/src/main/assets/index.android.bundle 这句命令是重点，如果assets目录中不存在该文件，则打包的apk在执行时显示空白。 注意Protocol ‘http not supported or disabled in libcurlWindows下安装使用curl命令:http://jingyan.baidu.com/article/a681b0dec4c67a3b1943467c.html 4.添加gradle的android keystore配置 打包的apk在未签名的情况下,在手机中（非root）是不允许安装的 在build.gradle文件中 12//签名signingConfigs&#123; release &#123; storeFile file("/my-release-key.keystore") storePassword "密码" keyAlias "keyAlias的名字" keyPassword "密码" &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release //添加这句话引用签名配置 &#125; &#125; 5.启用Proguard代码混淆来缩小APK文件的大小 Proguard是一个Java字节码混淆压缩工具，它可以移除掉React Native Java（和它的依赖库中）中没有被使用到的部分，最终有效的减少APK的大小。 重要：启用Proguard之后，你必须再次全面地测试你的应用。Proguard有时候需要为你引入的每个原生库做一些额外的配置。参见app/proguard-rules.pro文件。 1def enableProguardInReleaseBuilds = true 6.在/android/目录中执行gradle assembleRelease命令，打包后的文件在 android/app/build/outputs/apk目录中，例如app-release.apk。如果打包碰到问题可以先执行 gradle clean 清理一下。 7.将apk发布到各大应用市场（BUILD SUCCESSFUL） 8.mac环境变量配置path找到 ~/.bash_profile添加,检查一下对应的gradle信息保证存在 12export GRADLE_HOME=/Applications/Android\ Studio.app/Contents/gradle/gradle-3.3export PATH=$&#123;PATH&#125;:$&#123;GRADLE_HOME&#125;/bin 退出编辑,执行下面命名生效 1source .bash_profile 配置完成之后，运行gradle -v，检查一下是否安装无误 如果权限不够 1chmod gradle.bat 参考地址]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[codepush使用]]></title>
    <url>%2F2017%2F08%2F07%2Fcodepush%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介CodePush是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新到 (JS, HTML, CSS and images)，应用可以从客户端 SDKs 里面查询更新。CodePush 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。 codepush官方地址 文档 安装说明安装 1npm install -g code-push-cli 注册账号/登录（Register/Login,命令还是会自动打开浏览器，复制这个Key(会等待一会) 1code-push login 1234567code-push access-key &lt;command&gt;命令： add 添加一个新的Access Key remove 删除一个已经存在的Access key rm 删除一个已经存在的Access key list 列出与你账户关联的所有Access key ls 列出与你账户关联的所有Access key 创建新的app,安卓和ios分别建立对应app 123code-push app add &lt;AppName&gt;示例： code-push app add AppDemo 其它命令： 123456789code-push app &lt;command&gt;命令： add 创建一个新的App remove 删除App rm 删除App rename 重命名已经存在App list 列出与你账户关联的所有App ls 列出与你账户关联的所有App transfer 将一个App的所有权转让给另一个帐户 部署app列出App中所有部署 1234567code-push deployment ls &lt;appName&gt; [--format &lt;format&gt;] [--displayKeys]选项： --format 终端打印格式 ("json" or "table") [string] [默认值: "table"] --displayKeys, -k 是否显示Deployment Key [boolean] [默认值: false]示例： code-push deployment ls MyApp code-push deployment ls MyApp --format json 相关其他命令 1234567891011Usage: code-push deployment &lt;command&gt;命令： add 在已存在的App中创建一个部署 clear 清除与部署相关的发布历史记录,删掉 remove 在App中删除一个部署 rm 在App中删除一个部署 rename 重命名一个已存在的部署 list 列出App中的所有部署 ls 列出App中的所有部署 history 列出一个部署的发布历史记录 h 列出一个部署的发布历史记录 发布（Release） 第一步 12345678## 创建文件夹打包路径文件夹 mkdir ios/bundle android/bundle## ios的路径react-native bundle --entry-file index.ios.js --bundle-output ios/bundle/main.jsbundle --assets-dest ios/bundle## android的路径react-native bundle --entry-file index.android.js --bundle-output android/bundle/index.android.bundle --assets-dest android/bundle 第二步 1234567code-push release FindFood-ios -d Production ios/bundle/main.jsbundle 1.0.0## 测试code-push release FindFood-ios -d Staging ios/bundle/main.jsbundle 1.0.0 react-native bundle --platform android --entry-file index.android.js --bundle-output android/bundle/main.jsbundle --assets-dest android/bundle --dev falsecode-push release FindFood-android -d Staging android/bundle/index.android.bundle 1.0.0 下面代码会崩溃 1code-push release-react app_android android --dev false --d Production -m true andriod打包bug代码,看react-native-code-push/issues:After code-push release-react, device will Crash解释 123456789101112131415161718code-push release-reactUsage: code-push release-react &lt;appName&gt; &lt;platform&gt; [options]Options: --bundleName, -b Name of the generated JS bundle file. If unspecified, the standard bundle name will be used, depending on the specified platform: "main.jsbundle" (iOS) and "index.android.bundle" (Android) [string] [default: null] --deploymentName, -d Deployment to release the update to [string] [default: "Staging"] --description, --des Description of the changes made to the app with this release [string] [default: null] --development, --dev Specifies whether to generate a dev or release build [boolean] [default: false] --disabled, -x Specifies whether this release should be immediately downloadable [boolean] [default: false] --entryFile, -e Path to the app's entry Javascript file. If omitted, "index.&lt;platform&gt;.js" and then "index.js" will be used (if they exist) [string] [default: null] --mandatory, -m Specifies whether this release should be considered mandatory [boolean] [default: false] --rollout, -r Percentage of users this release should be immediately available to [string] [default: "100%"] --sourcemapOutput, -s Path to where the sourcemap for the resulting bundle should be written. If omitted, a sourcemap will not be generated. [string] [default: null] --targetBinaryVersion, -t Semver expression that specifies the binary app version(s) this release is targetting (e.g. 1.1.0, ~1.2.3). If omitted, the release will target the exact version specified in the "Info.plist" (iOS) or "build.gradle" (Android) files. [string] [default: null]Examples: release-react MyApp ios Releases the React Native iOS project in the current working directory to the "MyApp" app's "Staging" deployment release-react MyApp android -d Production Releases the React Native Android project in the current working directory to the "MyApp" app's "Production" deployment 查看发布历史 12code-push deployment history FindFood-ios Productioncode-push deployment history FindFood-ios Staging 参考地址参考地址2]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重新发送testflight邀请]]></title>
    <url>%2F2017%2F07%2F27%2F%E9%87%8D%E6%96%B0testflight%E9%82%80%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[由于之前的邀请码被别人占用导致要重新发送邀请码到这个邮箱帐号1.在下图1所有测试人员中删掉这个邮箱.2.在下图2itunes connect用户重新添加这个邮箱,这个时候会重新发送邀请码 参考地址1 stackoverflow]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nvm使用记录]]></title>
    <url>%2F2017%2F07%2F09%2Fnvm%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[nvm全称Node Version Manager.解决问题:安装和管理多版本Node,适用于mac系统,官方地址nvmwidows下参考地址nvm-windows 1.卸载已安装到全局的 node/npm12345npm ls -g --depth=0 #查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装sudo rm -rf /usr/local/lib/node_modules #删除全局 node_modules 目录sudo rm /usr/local/bin/node #删除 nodecd /usr/local/bin &amp;&amp; ls -l | grep "../lib/node_modules/" | awk '&#123;print $9&#125;'| xargs rm #删除全局 node 模块注册的软链 其他删除指令 12345678sudo rm /usr/local/bin/npmsudo rm /usr/local/share/man/man1/node.1sudo rm /usr/local/lib/dtrace/node.dsudo rm -rf ~/.npmsudo rm -rf ~/.node-gypsudo rm /opt/local/bin/nodesudo rm /opt/local/include/nodesudo rm -rf /opt/local/lib/node_modules 2.安装NVM（前提是你安装了homebrew）1$ brew install nvm 12345$ nvm ls-remote 查看 所有的node可用版本$ nvm install xxx 下载你想要的版本$ nvm use xxx 使用指定版本的node $ nvm alias default xxx 每次启动终端都使用该版本的node $ nvm install stable 最新版本 123npm install -g react-native-cli #安装 react-native-cli 模块至全局目录，安装完成的路径是 /Users/&lt;你的用户名&gt;/.nvm/versions/node/v4.2.2/lib/react-native-clinpm install hexo-cli -g 3.查看安装结果12$ node -v$ npm -v 4.卸载nvm1$ rm -rf ~/.nvm 5.nvm 使用淘宝镜像在~/.zshrc文件中增加export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node然后在 source ~/.zshrc 参考地址1 参考地址1 nvm 使用淘宝镜像]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用软件配置同步]]></title>
    <url>%2F2017%2F06%2F30%2F%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[目的:在不同mac之间做一些常用软件的配置同步,使用坚果云作为备份云端. 1.科学上网助手ShadowsocksX-NG同步配置地址,里面有pac规则自定义的,xxx为自己的用户名 1/Users/xxx/.ShadowsocksX-NG 2.alfred配置文件同步.同步配置地址 alfred -&gt;配置(preferrence)-&gt;右下角文件1/Users/xxx/.ShadowsocksX-NG 下载地址 3.iterm2的配置文件1/Library/Preferences/com.googlecode.iterm2.plist 恢复默认 1defaults delete com.googlecode.iterm2]]></content>
      <categories>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo错误记录]]></title>
    <url>%2F2017%2F06%2F28%2Fhexo%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[常见问题使用帮助 官方 http://hexo.io/docs/troubleshooting.html hexo-issues-geithub 1.错误代码1hexo generate fail - Template render error: (unknown path) 检查代码&quot;\{\{ \}\}&quot;改成&quot;\{\{ \}\}&quot;,前面的去掉\是,这里为了保证输入正确 检查代码&quot;\{\%\}&quot;改成&quot;\{\%\}&quot; 删除多余的换行 2.错误代码Module version mismatch. Expected 48, got 47重新安装一下 1sudo npm install hexo --no-optional 3.两个电脑上配置问题ERROR Local hexo not found in ~/hexo_blogERROR Try running: ‘npm install hexo –save’ 使用node 6.14.2 和删掉 nodemodles 文件夹1nvm install 6.14.2 4.升级NexT v6.0.0以上下载新版本到themes把文件夹改名为next 5.Cannot find module ‘hexo-util’重新安装 1npm install -- save-dev hexo-util 切换到master分支进行提交部署hexo d]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactNative错误收集(Andriod)]]></title>
    <url>%2F2017%2F05%2F15%2FReactNative%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86(Android)%2F</url>
    <content type="text"><![CDATA[错误一:小米5进行程序调试 出现下面的问题问题描述: 12345678* What went wrong:Execution failed for task ':app:installDebug'.&gt; com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Failed to establish session* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.BUILD FAILED 1.执行了一下 adb devices 命令的时候看到设备是否经连接上了。2.在小米手机里面点miui版本打开开发者调试 ,然后再去设置`小米手机设置-&gt;开发者选项-&gt;启用MIUI优化关闭。 错误二:12345jax$ react-native run-androidStarting JS server...Building and installing the app on the device (cd android &amp;&amp; ./gradlew installDebug...Could not install the app on the device, read the error above for details. 执行下面的命令chmod 755 android/gradlewfacebook/react-native 错误三:zsh: command not found: adb1.解决办法在~/.zshrc文件里面添加找到.zshrc文件 中“# User configuration” 位置加入 “source ~/.bash_profile”(前提是bash_profile文件中的环境变量 你已经各种配置好了)2.重启命令行]]></content>
      <categories>
        <category>BFE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 私有库]]></title>
    <url>%2F2017%2F04%2F20%2Fcocopods-%E7%A7%81%E6%9C%89%E5%BA%93%2F</url>
    <content type="text"><![CDATA[整理一下CocoaPods 私有库相关使用问题 一.创建Pod项目工程文件 1.在GitLab上创建XXCommonSDK项目,cd进入到要创建项目的目录，然后终端执行以下命令创建工程： 1# pod lib create XXCommonSDK 接着在控制台就会输出以下几个问题让你来回答： 完成以上的问题后控制台会输出以下信息 ，然后自动打开所创建的项目 2.在以下截图的目录下添加你的实现代码，里面自带一个ReplaceMe.m文件，直接删除它就好了，添加你自己的.h.m实现文件 ，如下图： 3.修改Podfile文件，打开工程目录下Example目录的Podfile文件，修改如下提交仓库到 git： 123456git add .git commit -s -m 'init'git remote add origin http://xxxx:user/XXCommonSDK_iOS.git #添加远端仓库git push origin master #提交到远端仓库git tag -m "first release" 0.1.0git push --tags #推送tag到远端仓库 因为podspec文件中获取Git版本控制的项目还需要tag号，所以我们要打上一个tag， 4.编辑podspec,http://xxxx.xxx.xxx需要替换为实际的地址,官方文档 12345678910111213141516171819202122232425262728293031323334Pod::Spec.new do |s| s.name = 'JlCommonSDK' #名称 s.version = '0.1.0' #版本号 s.summary = 'A short description of JlCommonSDK.' #简短介绍，下面是详细介绍# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don't worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC s.homepage = 'http://xxxx.xxx.xxx' # s.screenshots = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; 'sukeyang =&gt; '410900345@qq.com' &#125; s.source = &#123; :git =&gt; 'http://xxxx.xxx.xxx', :tag =&gt; s.version.to_s &#125; # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' s.ios.deployment_target = '8.0' s.source_files = 'XXCommonSDK/Classes/**/*' # s.resource_bundles = &#123; # 'JlCommonSDK' =&gt; ['JlCommonSDK/Assets/*.png'] # &#125; # s.public_header_files = 'Pod/Classes/**/*.h' # s.frameworks = 'UIKit', 'MapKit' # s.dependency 'AFNetworking', '~&gt; 2.3'end 5.验证文件podspec正确性, podspec里面的描述信息,是我们可以获取到正确的文件,这个后面会提交到私有库索引的列表里面. 123pod lib lint//或者pod spec lint --use-libraries --allow-warnings --verbose //忽略警告 1XXCommonSDK passed validation. 警告可以进行忽略,下面的 1[!] XXCommonSDK did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it). 向Spec Repo提交podspec 1.可以查看 ~/.cocoapods/repos 目录下的文件,里面有每个三方库文件的对应版本podspec 在gitlab上另外建立一个SukSpecs项目（管理所有的pod spec文件）, 1pod repo add SukSpecs git@xxx:xxx/SukSpecs.git 2.添加成功之后可以,进行查看pod的三方库下载的查找索引地址, 1pod repo 123456789master- Type: git (master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/hl/.cocoapods/repos/masterSukSpecs- Type: git (master)- URL: git@xxx/iOSPGSDK.git- Path: /Users/hl/.cocoapods/repos/SukSpecs 3.进入到上面第五步的pod 目录找到XXCommonSDK.podspec目录,提交到我们自己的私有仓库 1pod repo push SukSpecs XXCommonSDK.podspec 可以到 ~/.cocoapods/repos/SukSpecs 目录下的文件查看,这个目录也是一个 git 文件夹,可以用git图像页面工具进行修改管理SourceTree. 4.使用制作好的Pod 我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下一行代码即可 1pod 'XXCommonSDK', '~&gt; 0.1.0' 升级维护私有库 1.在Pod项目工程文件,修改添加代码,进行提交,一定要打tag 12$ git tag -m "first release" 0.1.0$ git push --tags #推送tag到远端仓库 2.提交podspec到我们的私有仓库, podspec里面的版本号s.version 和上面的Pod项目工程文件的 tag是对应的 1pod repo push SukSpecs XXCommonSDK.podspec 3.在式项目中使用这个私有的Pod的工程目录下 1pod update 参考地址 参考地址2]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AFN实现原理分析(2.x版本)]]></title>
    <url>%2F2017%2F02%2F27%2FAFN%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[使用AFHTTPSessionManager进行网络请求,类继承于AFURLSessionManager 12345678AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager GET:URL parameters:nil progress:nil success:^(NSURLSessionDataTask *_Nonnulltask, id _NullableresponseObject) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; //将子线程从网络拉取的数据用于主线程刷新视图 &#125;); &#125;failure:^(NSURLSessionDataTask*_Nullabletask,NSError*_Nonnullerror) &#123;&#125;]; 通过查看manager方法代码可以看到其实现最终是调用了父类AFURLSessionManager的initWithSessionConfiguration：方法， 设置了默认的json解析方式; 最大的并发操作数为1是让所有请求的发起和等待网络响应均在同一条线程中执行，而不用为每一个请求都新建一条线程，这样节约了很多资源; 默认安全策略是AFSSLPinningModeNone, 该方法代码片段如下 12345self.sessionConfiguration = configuration;self.operationQueue = [[NSOperationQueue alloc] init];self.operationQueue.maxConcurrentOperationCount = 1;self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];self.responseSerializer = [AFJSONResponseSerializer serializer]; 在响应到达后会执行AFURLSessionManager的NSURLSessionDataDelegate协议的方法，[AFURLSessioinManager URLSession:dataTask:didReceiveData:]用于查找对应的响应代理，并将后续的数据处理如数据拼接转交给该代理。该方法的实现代码如下： 123456AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];[delegate URLSession:session dataTask:dataTask didReceiveData:data];if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data);&#125; 在数据比较大时，改方法可能会多次执行。 当数据传输完成后会调用[AFURLSessioinManager URLSession:task:didCompleteWithError],该方法用于让对应的代理执行NSURLSessionTaskDelegate协议中的方法，并将该代理对象从字典中移除，源代码如下： 123456789101112AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];// delegate may be nil when completing a task in the backgroundif (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task];&#125;if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error);&#125; 随后代理执行URLSession:task:didCompleteWithError:，该方法把数据放到另一个由静态方法生成的url_session_manager_processing_queue操作队列中做数据解析，如json解析，并将解析后的数据回传到主线程或者你自己生成的操作队列里，通过通知中心将请求完成的消息传递到主线程去（后面会写一篇文章介绍通知中心的实现原理,并写一个类似的通知中心）。该方法源码片段如下： 1234567891011121314dispatch_async(url_session_manager_processing_queue(), ^&#123; NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:[NSData dataWithData:self.mutableData] error:&amp;serializationError]; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); 通知的作用是decrementActivityCount; [self.refreshControl endRefreshing];等]]></content>
      <categories>
        <category>原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[weex使用介绍]]></title>
    <url>%2F2017%2F02%2F17%2Fweex%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近在折腾weex,不过升级到vue2.0出现了一些问题,现在记录使用情况,暂时有一些问题没有解决,官方的链接:weex官方github weex-devtool-iOS weexteam-demo 基本介绍1.安装环境,nodejs,下面是一些常用的命令. IDE: Sublime Text + vue-syntax-highlight + HTML-CSS-JS Prettify 1234npm installsudo npm install -g weex-toolkit@betanpm run buildnpm run copy:ios 2.开启服务 1npm run serve 3.开启debug,自动弹出页面 1weex debug --verbose]]></content>
      <categories>
        <category>BFE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库知识]]></title>
    <url>%2F2017%2F02%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1.’主键和唯一索引’; 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。 唯一性索引列允许空值，而主键列不允许为空值。 主键列在创建时，已经默认为空值 + 唯一索引了。 主键可以被其他表引用为外键，而唯一索引不能。 一个表最多只能创建一个主键，但可以创建多个唯一索引。主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js基本用法(三)]]></title>
    <url>%2F2017%2F02%2F13%2Fxuejs3%2F</url>
    <content type="text"><![CDATA[继承1.js没有类的概念,只有对象,就是继承也是通过对象的方式;constructor类似于类初始化函数,prototype 是个类的对象;2.保持原型链路的基础上,对父类对象的属性隔离;保证重用; var F = function(){}; F.prototype = TwoShape.prototype; Triangle.prototype = new F(); 3.将uber属性设置成了指向其父级原型的引用; my.uber = TwoShape.prototype; 4.继承函数封装,具体原理不懂; function extend(Child,Parent) { var F = function(){}; F.prototype = Parent.prototype; Child.prototype = new F; Child.prototype.constructor = Child; Child.uber = Parent.prototype; extend(TwoShape,shape);//使用内容 属性的拷贝为自身的,基本数据类型是创建新的,函数和数组都是值的引用;新创建相当于忘记之前的对象,重新生成一个对象; function extend2(Child, Parent) { var p = Parent.prototype; var c = Child.prototype; for (var i in p ){ c[i] = p[i]; c.uber = p; } } prototype是什么含义？javascript中的每个对象都有prototype属性，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。A.prototype = new B();理解prototype不应把它和继承混淆。A的prototype为B的一个实例，可以理解A将B中的方法和属性全部克隆了一遍。A能使用B的方法和属性。这里强调的是克隆而不是继承。可以出现这种情况：A的prototype是B的实例，同时B的prototype也是A的实例。 DOM环境1.访问标签,计时器,修改样式等 1234567var inputs = document.getElementsByTagName('button');function toggle ()&#123; var st = inputs[0].style; inputs[0].style.visibility = (st.visibility == "hidden")?"visible":"hidden";&#125;var myint = setInterval(toggle,1000);clearInterval(myint); 2.创建添加节点 1234var myp = document.createElement("p");myp.innerHTML = "yet another";myp.style.border = "2px dotted blue";document.body.appendChild(myp) 3.插入节点,删除节点 12document.body.insertBefore(p,document.body.firstChild)document.body.removeChild(myp) 4.其他常用方法 12document.title ="123"; //不改变实际标签内容document.cookie; 5.捕捉法和冒泡法]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js基本用法(四)]]></title>
    <url>%2F2017%2F02%2F13%2Fxuejs4%2F</url>
    <content type="text"><![CDATA[1.’use strict’; 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 Javascript 严格模式详解 2.yarn的用法,官网 安装12npm install --save 等于 yarn addnpm install 等于 yarn 地址 移除依赖包 1yarn remove [package] 升级依赖包 123yarn upgrade [package]yarn upgrade [package]@[version]yarn upgrade [package]@[tag] 其他命令 1yarn list [package] 更换淘宝镜像 123yarn config get registry# -&gt; https://registry.yarnpkg.comyarn config set registry 'https://registry.npm.taobao.org' 3. props和state 永远都不要给 props 直接赋值,外面传递 永远都不要给 state 直接赋值，通过 setState用this.setState() 会触发数据流变动重新调用 render 函数,用this.state.value不会，应该是setState()函数里面有某些hook钩子函数。异步方法,里面有设置完成的回调函数 4. Object.defineProperty12345var a= &#123;&#125; Object.defineProperty(a,"b",&#123; value:123 &#125;) console.log(a.b);//123 它接受三个参数都是必填的。。 传入参数第一个参数:目标对象 第二个参数:需要定义的属性或方法的名字。 第三个参数:目标属性所拥有的特性。（descriptor） 前两个参数不多说了，一看代码就懂，主要看第三个参数descriptor，看看有哪些取值 descriptor他又以下取值，我们简单认识一下，后面例子，挨个介绍， value:属性的值(不用多说了) writable:如果为false，属性的值就不能被重写,只能为只读了 configurable:总开关，一旦为false，就不能再设置他的（value，writable，configurable） enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。 5 obj1.func.call(obj)方法意思是将obj看成obj1,调用func方法 6 Array.prototype.slice.call()方法详解arguments并不是真正的数组对象，只是与数组类似而已，所以它并没有slice这个方法，而Array.prototype.slice.call(arguments)可以理解成是让arguments转换成一个数组对象，让arguments具有slice()方法Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组将函数的实际参数转换成数组的方法!方法一：var args = Array.prototype.slice.call(arguments); 方法二：var args = [].slice.call(arguments, 0); 方法三： var args = [];for (var i = 1; i &lt; arguments.length; i++) { args.push(arguments[i]);}参考 7.Javascript中apply、call、bindjavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数。bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js基本用法(二)]]></title>
    <url>%2F2017%2F02%2F10%2Fxuejs2%2F</url>
    <content type="text"><![CDATA[常见类1.Boolean 验证类的布尔值 Boolean(&quot;&quot;) false Boolean(&quot;123&quot;) true 2.Number任何都转成number,toString加参数转换 var n = Number(&quot;123&quot;) n.toString(2) //1111011 3.String类对象方法 test.toUpperCase(); test.toLocaleLowerCase() test.indexOf(&quot;m&quot;,2) //返回某个指定的字符串值在字符串中2出现的位置。找不到为-1 test.charAt(0) 字符串的搜索用下面的方式 if(test.indexOf (&quot;c&quot;) == -1){ alert(&quot;yes&quot;); } substring() 提取字符串中两个指定的索引号之间的字符。split() 把字符串分割为字符串数组。concat() 连接两个或更多字符串，并返回新的字符串。lastIndexOf() 从后向前搜索字符串。4.math类常用数学常数 Math.random()*100 8*Math.random()+2 //2到10之间的某一个数 Math.round(Math.random()*10) //四舍五人 Math.ceil(Math.random()*10) //取值 Math.floor(Math.random()*10) //舍去 Math.min(1,10) 取最小值 Math.max(1,10) 取最大值 Math.pow(2,4) 指数运算 Math.sqrt(9); 平方根 5.Date类相关,不一个new则为当前日期 new Date(2008,0,1) //月从0开始计算 Tue Jan 01 2008 00:00:00 GMT+0800 (CST) dateTest.setMonth(2) //设置为3月 dateTest.getMonth() // 2 Date.parse(&quot;Jan 1,2009&quot;) //转为时间戳 ateTest.getDay() //获取星期几 0为每星期的第一天 6.正则表达式 var re = new RegExp(&quot;j.*t&quot;,&quot;gmi&quot;); 修饰符 描述,一旦设置不能更改i 执行对大小写不敏感的匹配。默认falseg 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。默认falsem 执行多行匹配 默认false var s = new String(&quot;HelloJavaScriptWorld&quot;); s.match(/a/); //匹配字符串 s.search(/j.*a/i); //匹配字符串索引位置 s.replace(/[A-Z]/g,&apos;&apos;); //替换为空字符串 replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。()为分组匹配分组的第一组;这些函数还可以匹配普通字符串; var email = &quot;stoyan@phpied.com&quot;; var username= email.replace(/(.*)@.*/,&quot;$1&quot;); var callback = function(){ glob = arguments; return arguments[1] +&quot; at&quot; + arguments[2] + &quot; dot &quot; + arguments[3]; } &quot;stoyan@phpied.com&quot;.replace(/(.*)@(.*)\.(.*)/, callback); //分组 &quot;stoyan atphpied dot com&quot; var csv = &quot;one, two, three, four&quot;; csv.split(/\s*,\s*/); //空格匹配; 7.error错误捕捉,,自定义错误对象, try { idont(); } catch (e) { alert(e.name + &apos;: &apos; + e.message); } try { var total = mybeE(); if(total === 0) { throw new Error(&quot;division by zero&quot;); } else { alert(50/total); } } catch (e){ alert(e.name + &apos;: &apos; + e.message); } 重要的属性-原型1.原型类似于父类的东西,gadget的父类gadget.prototype,可以增加属性,可以修改原型,然后影响原来的对象 function gadget (name ,color) { this.name = name; this.color = color; this.whatAreYou = function () { return &quot;i am a &quot; + this.color + &quot; &quot; +this.name; } } gadget.prototype = { price : 100, rating: 3, getInfo :function() { return &quot;rating&quot; + this.rating + &quot; price&quot; + this.price; } } 2.对象自身属性没有找到指定的属性,会去原型里面继续查找,如果相同,以对象的属性为准;打印属性; for (var prop in newToy) { console.log(prop + &quot; = &quot; + newToy[prop]); newToy.hasOwnProperty属于自身的属性 for (var prop in newToy) { if(newToy.hasOwnProperty(prop)){ console.log(prop + &quot; = &quot; + newToy[prop]); }} newToy.propertyIsEnumerable自身属性为true,原型中的为false;monke是对象george的原型; monkey.isPrototypeOf(george); 3.prototype和proto属性不是等价的,prototype改变并不会影响到proto monkey.test = 1; developer.test; //修改monkey的属性,修改developer内容; 4.扩展内建函数常用Array,相当于iOS分类 Array.prototype.inArray = function (needle) { for (var i = 0,len = this.length;i&lt; len;i++){ if (this[i] === needle) { return true; } } } 5.判断函数是否可以使用,如果想添加一个属性或者方法最好看是不是已经存在其中; if (!String.prototype.reverse) { alert(&quot;1111&quot;); } 6.当我们重写某对象的prototype时候,重置相应的constructor是一个好习惯;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js基本用法(一)]]></title>
    <url>%2F2017%2F02%2F10%2Fxuejs1%2F</url>
    <content type="text"><![CDATA[基本用法1.不用new的话,this会变成全局变量 function Hero(name) { this.name = name ;}; var h1 = Hero(&quot;ceshi&quot;); 2.大小写严格3.Infinity 超出处理范围的数值 1e309,4.NaN依旧是number,typeof NaN可以查看,特殊数字5.数字字符串做运算,会当成数字类型使用,转换失败就是NaN,偷懒做法是1*s转换成数字, var s = &quot;1&quot;;s = 3*s var s = &quot;100&quot;;s = 1*s var s = &quot;1avbc&quot;;s = 3*s 加法不适用 var s = &quot;1&quot;;s += 3 6.加法是用来把数字转成字符串,取巧的方式 var s = &quot;1&quot;;s += 3 7.空字符串””,null,undefined,0,NaN,false都是false8.===等价运算 1 === &apos;1&apos; false !== 不能价运算 NaN == NaN false 9.undefined为不存在或者未经过赋值的变量,和nul在转换基本类型时有区别 &quot;&quot; + null &quot;null&quot; &quot;&quot; + undefined undefined 数据操作1.数组操作 delete a[1] length属性为太长自动填充 undefined a.push(&quot;last&quot;) //添加到最后 a.pop() //删掉最后 a.sort() //排序 a.join(&quot;is &quot;) //连接&quot;1is is is &quot; a.slice(1,2) //查看 a.splice(1,2,100,200,300) //删掉并添加新的[1, 100, 200, 300, undefined × 1] 2.判断数组存在 if(typeof somevar == &quot;undefined&quot;) {result = &quot;yes&quot;}; &quot;yes&quot; 3.常用函数parseInt() 默认十进制,看后面参数的开头”0x”,”0337”应该避免为8进制 parseInt(&quot;123abc&quot;) 123 parseInt(&quot;FF&quot;,16) 255 parseInt(&quot;0x34&quot;) 4.isNaN函数其实等同于回答了这样一个问题：这个值被强制转换成数值时会不会返回IEEE-754​中所谓的”不是数值“（not a number）。 isNaN({}); // true isNaN(&quot;37&quot;); // false: 可以被转换成数值37 5.你可以用这个方法来判定一个数字是否是有限数字。isFinite 方法检测它参数的数值。如果参数是 NaN，正无穷大或者负无穷大，会返回false，其他返回 true。 isFinite(2e64); // true isFinite(Infinity); // false 6.encodeURI() 是对统一资源标识符（URI）进行编码的方法。它使用1到4个转义序列来表示每个字符的UTF-8编码encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。 encodeURI() encodeURIComponent() 7.eval(string) 一个字符串表示了一个JavaScript表达式，声明， 或声明的序列。表达式可以包括变量和已存在对象的属性。 eval(string) 8.总是使用var 来声明全局变量9.f()执行之后,n()为全局变量,或者返回给全局空间声明,保留了作用域内参数b的值,记录自身在的环境和相关的参数. 1234567 var n; function f()&#123; var b = "b"; n = function()&#123; return b; &#125;&#125; 留住的是指针,用get,set函数闭包建立私有变量,迭代器. 对象操作1.属性名字一般不加引号,除非:为js保留字,含有特殊字符,用数字开头的属性2.属性可以是函数,函数是一种数据类型.3.属性不能用.进行调用和(1)条件一致4.this标识当前对象.5.不用new 生成对象 this引用的是window全局对象.6.对象有一个constructor 构造器属性7.h12 instanceof Hero 是否有某一个对象初始化来的8.控制输出数据的内容,函数也是对象也是一种数据类型 console.info(h12) console.log() console.error() 9.一些方法,o会自动调用toString toString &quot;an object&quot; + o 10.valueOf()返回对象本身. o.valueOf() === o 11.尽量避免使用Function 构造器函数,权限太大 var sum = new Function(&quot;a,b&quot;,&quot;return a + b&quot;) sum.length //参数个数 2 12.caller返回调用函数 function A(){return A.caller;} function B(){return A();} 13.prototype为构造函数的内容,该属性为一个对象 prototype 14.some_obj.say.call(my_obj,’myobje’)为让my_obj 执行say 函数,并且传入参数.本质是修改了this的值,some_obj.say.apply(my_obj,[‘ceshi’])为apply 参数为一个数组形式的12345678var some_obj = &#123; name:'nanne', say:function(who)&#123; return 'haya ' + who + ', i am a ' +this.name; &#125;&#125;some_obj.say.apply(my_obj,['ceshi']) 15.arguments.callee属性为当前的函数对象,arguments数组,没有sort和slice方法 ( function (count) { if(count &lt; 5){ alert(count); arguments.callee(++count); } } )(1)]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016总结]]></title>
    <url>%2F2017%2F02%2F06%2F2016%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[生活上减肥5kg,少吃肉类,鱼类看电影5次 电影院看书5本 包括js 还有es6,微信小程序等内容微信个人公众号后台开发初识出去旅游3次,包括北京周边开通自己的博客或者简书写博客10篇内容听书 鬼吹灯全集 不算书 工作上keynote 的制作等做分享 3次 ,工资提升提升用户到2k 活跃到2w 更新内容,10次,每月都的多100人.页面的优化 已经完成20170226 骑车ofo到圆明园,一次游玩201702025 看完&lt;JavaScript面向对象编程指南&gt;]]></content>
      <categories>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[斐讯k2路由器刷华硕固件]]></title>
    <url>%2F2016%2F12%2F18%2F%E6%96%90%E8%AE%AFk2%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.下载软件需要安装的软件,网盘地址https://pan.baidu.com/s/1c2J6CnQ里面有k2_163_v11_breed.bin 和SW_K2_703004657_V22.4.2.8.bin，然后升级进入斐讯路由器选择升级，选择k2_163_v11_breed.bin这个文件，等待升级完成 2.升级完成后，断开路由器电源然后按住复位键，插上电源，按住等待7秒钟，然后在浏览上输入：192.168.1.1 3.进入breed web设置页面，先在breed“环境变量设置”中改为“禁用”然后保存，并重启路由器。然后回到breed界面，在菜单固件更新中，选择固件哪行，上传已经下载的SW_K2_703004657_V22.4.2.8.bin 固件，等待上传完成，然后点击更新。请等待升级完成，自动重启后。然后按住复位键7秒，等待重启后。到此你的路由器固件成功降级到了22.4.2.8 4.同时可以刷最新华硕固件:在步骤3中的breed界面,下载下面的固件进行升级.不使用上面压缩包里面的固件.最新华硕固件: 链接:http://pan.baidu.com/s/1geZnaz5 密码: mdex 123456华硕固件默认配置旧固件网关：192.168.1.1新固件网关：192.168.123.1管理页面：http://my.router/管理账号：admin/adminwifi:1234567890 刷机不恢复默认值潘多拉固件：链接: http://pan.baidu.com/s/1nvKy4mX 密码: w5p7账号/密码 ： root/admin 参考地址1 参考地址2 参考地址3]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Sublime Text 进行Markdown 编辑]]></title>
    <url>%2F2016%2F12%2F18%2F%E4%BD%BF%E7%94%A8SublimeText%E8%BF%9B%E8%A1%8CMarkdown%E7%BC%96%E8%BE%91%2F</url>
    <content type="text"><![CDATA[安装包管理器同时按下ctrl+”`”,将会在窗口底部出现一个小控制台，下面代码粘贴到控制台的编辑栏里： 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 安装不上的问题，看官方办法 安装我们要用到的插件12Markdown Editing // Markdown编辑和语法高亮支持 Markdown Preview// Markdown导出html预览支持 插件配置1.在设置里面Sublime Text – &gt;preference–&gt; key bunding user 输入 123[ &#123;"keys": ["alt+r"], "command": "markdown_preview", "args": &#123; "target": "browser"&#125;&#125;] 然后按住alt + r ，预览你编辑的文件吧。]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactNative错误收集问题]]></title>
    <url>%2F2016%2F12%2F15%2FReactNative%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86(iOS)%2F</url>
    <content type="text"><![CDATA[错误一:Unable to resolve module image!方法: 在 Xcode 下 Images.xcassets 里面明确的有这个图片。 错误二:低版本兼容,Log类接口修改, 添加 RCTLogSource source 即可.RCTSetLogFunction(^(RCTLogLevel level, RCTLogSource source, NSString *fileName, NSNumber *lineNumber, NSString *message) 错误三:RCTSRWebSocket.m报错,代码在下面SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key); 修改为: (void)SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key); 错误四: Seem you’re trying to access ‘ReactNative.createClass’ from the ‘react-native package;var React = require(&apos;react&apos;); var component = React.createClass(); RN升级导致的问题,官方解决 错误五:重新安装sdk,react@15.3.1是sdk版本123456789watchman watch-del-allrm -rf node_modulesnpm install react@15.3.1 --savenpm installrm -fr $TMPDIR/react-*npm start -- --reset-cache ``` ##错误六:错误是下面提示方法:other flag 添加标识 -lc++ Undefined symbols for architecture x86_64: “std::1::next_prime(unsigned long)”, referenced from: std::1::hash_table&lt;std::1::hash_value_type, std::1::unordered_map_hasher&lt;unsigned long, std::1::hash_value_type, std::1::hash, true&gt;, std::1::unordered_map_equal&lt;unsigned long, std::1::hash_value_type, std::1::equal_to, true&gt;, std::1::allocator&lt;std::1::hash_value_type &gt; &gt;::rehash(unsigned long) in libReact.a(RCTJSCExecutor.o) “std::1::mutex::lock()”, referenced from: -[RCTModuleData setUpInstanceAndBridge] in libReact.a(RCTModuleData.o) “std::1::mutex::unlock()”, referenced from: -[RCTModuleData setUpInstanceAndBridge] in libReact.a(RCTModuleData.o) “std::1::mutex::~mutex()”, referenced from: -[RCTModuleData .cxx_destruct] in libReact.a(RCTModuleData.o) “std::terminate()”, referenced from: _clang_call_terminate in libReact.a(RCTJSCExecutor.o) “operator delete“, referenced from: -[RCTJSCExecutor dealloc] in libReact.a(RCTJSCExecutor.o) executeRandomAccessModule(RCTJSCExecutor*, unsigned int, unsigned long, unsigned long) in libReact.a(RCTJSCExecutor.o) readRAMBundle(std::1::unique_ptr&lt;sFILE, int (*)(sFILE*)&gt;, RandomAccessBundleData&amp;) in libReact.a(RCTJSCExecutor.o)…..….. “_cxa_begin_catch”, referenced from: _clang_call_terminate in libReact.a(RCTJSCExecutor.o) “___gxx_personality_v0”, referenced from: -[RCTJavaScriptContext initWithJSContext:onThread:] in libReact.a(RCTJSCExecutor.o) -[RCTJavaScriptContext init] in libReact.a(RCTJSCExecutor.o) -[RCTJavaScriptContext invalidate] in libReact.a(RCTJSCExecutor.o) +[RCTJSCExecutor runRunLoopThread] in libReact.a(RCTJSCExecutor.o) -[RCTJSCExecutor setBridge:] in libReact.a(RCTJSCExecutor.o) -[RCTJSCExecutor init] in libReact.a(RCTJSCExecutor.o) -[RCTJSCExecutor initWithUseCustomJSCLibrary:] in libReact.a(RCTJSCExecutor.o) …ld: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation)12## 错误七: React Native cant find RCTEventEmitter after cocoapods integration解决方法: cleaning xcode under Product menu cmd + Kclearing rm ios/build/*react-native unlinksrc/ios $ pod clean &amp;&amp; pod deintegrate &amp;&amp; pod install1## 错误八:碰到的问题“Cannot find entry file index.ios.js in any of the roots:” Cannot find entry file index.ios.js in any of the roots: 123由于编译库node里面的版本不兼容导致,尝试以下做法升级npm npm install npm@latest -g12升级 react npm install -g react-native-git-upgrade123456删掉根目录下的 `package-lock.json` 重新 `npm install`## 错误九:No dimension set for key window npm start –reset-cache12## 错误10:错误描述 CodeSign /Users/yangshuo/Library/Developer/Xcode/DerivedData/shopkeeper-euiqdjptqdpqzcgwfumczgxlmjsf/Build/Products/Release-iphonesimulator/shopkeeper.app cd /Users/yangshuo/Documents/shengxincode/FIndFood/FindFood/ios export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH=”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin” Signing Identity: “-“ /usr/bin/codesign --force --sign - --timestamp=none /Users/yangshuo/Library/Developer/Xcode/DerivedData/shopkeeper-euiqdjptqdpqzcgwfumczgxlmjsf/Build/Products/Release-iphonesimulator/shopkeeper.app /Users/yangshuo/Library/Developer/Xcode/DerivedData/shopkeeper-euiqdjptqdpqzcgwfumczgxlmjsf/Build/Products/Release-iphonesimulator/shopkeeper.app: resource fork, Finder information, or similar detritus not allowedCommand /usr/bin/codesign failed with exit code 1 1解决办法 cd ~/Library/Developer/Xcode/DerivedDataxattr -rc .`解决办法:stackoverflow 参考文章 Yarn vs npm]]></content>
      <categories>
        <category>BFE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建自己Carthage支持的库(二)]]></title>
    <url>%2F2016%2F12%2F01%2F%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1Carthage%E6%94%AF%E6%8C%81%E7%9A%84%E5%BA%93%2F</url>
    <content type="text"><![CDATA[创建自己Carthage支持的库首先创建一个framework1.选择你的工程 2.选择framework所在的Target 3.选择Build Phases 4.点击Header左下角的+号把你要暴露的头文件添加到Public里面（默认添加到Project里面，用鼠标把它拽过去） 5.在Compile source里面添加实现的.m文件 在framework的BuildSettings的Packaging里面,把Produce Module Name 和 Produce Name改成想要的名字XXXX1.如果你使用了类别,那么你需要在Build Settings的Linking的Other Linker Flags里加上-all_load 2.如果你想你的工程支持bitcode,需要在Other C Flags 里加上-fembed-bitcode 3.选择 Manager Schemes,勾上shared(这样Carthage就可以编译你的工程) 4.cd到项目文件夹,运行 1$ carthage build --no-skip-current 命令运行完成后,你会发现你的项目文件夹里面多了一个Carthage文件夹Carthage-&gt;Build-&gt;iOS-&gt;xxxx.framework! 要给别人使用的话你还需要最后一步,给你的工程打上tag,push上去在Cartfile文件添加, 1github "yourname/xxxx" "master" 然后运行下面代码更新,frmework 1carthage update 参考连接创建自己的Cartfile支持的库]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Carthage安装及使用(一)]]></title>
    <url>%2F2016%2F12%2F01%2FCarthage%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介Carthage 使用于 Swift 语言编写，只支持动态框架，只支持 iOS8+的Cocoa依赖管理工具。是一个去中心化的Cocoa依赖管理工具;CocoaPods对原有工程破坏性大(建立workspace,增加一堆乱七八糟的文件),侵入性太强,耦合太高; 环境安装检查ruby和brew版本 12ruby -vbrew -v 如果电脑中没有Homebrew,终端执行脚本安装即可 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 方法1:更新brew,安装carthage 12brew updatebrew install carthage 方法2:下载安装Carthage.pkg 常见命令使用123carthage versionbrew upgrade carthage //升级sudo brew uninstall carthage //卸载 创建空的Cartfile文件 1touch Cartfile 打开Cartfile添加三方库信息,如 1github "Alamofire/Alamofire" ~&gt; 3.0 保存并关闭Cartfile文件并执行,--platform iOS 只是iOS平台 1carthage update --platform iOS 引入设置Xcode自动搜索Framework的目录,Target—&gt;Build Setting—&gt;Framework Search Path—&gt;添加路径下面 1＂$(SRCROOT)/Carthage/Build/iOS＂ 1.Cartfile.resolved (需要提交到 Git)在执行 carthage update 命令后会在根目录创建一个 Cartfile.resolved 文件，这个文件是生成后的依赖关系，不能修改。 Cartfile.resolved 文件确保提交的项目可以使用完全相同的配置与方式运行启用。 跟踪项目当前所用的依赖版本号，保持多端开发一致,出于这个原因,强烈建议提交这个文件到版本控制中 2.自动生成的Carthage目录 (不需要提交到 Git)Carthage文件夹用来存放: carthage checkout 从git拉取的依赖库源文件(Checkouts) carthage build编译后的文件(Build),包含Mac 与 iOS对应的.framework,文件夹用来存放依赖库的源文件和编译后的文件(不需要提交到 Git，可以修改.gitignore文件，增加忽略 Carthage 文件夹就行了：#Carthage Carthage）]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tableviewcell左对齐]]></title>
    <url>%2F2016%2F11%2F24%2Ftableviewcell%E5%B7%A6%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[1.解决tableview separatorInset cell分割线左对齐 1234567891011121314- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123; // Remove seperator inset if ([cell respondsToSelector:@selector(setSeparatorInset:)]) &#123; [cell setSeparatorInset:UIEdgeInsetsZero]; &#125; // Prevent the cell from inheriting the Table View's margin settings if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)]) &#123; [cell setPreservesSuperviewLayoutMargins:NO]; &#125; // Explictly set your cell's layout margins if ([cell respondsToSelector:@selector(setLayoutMargins:)]) &#123; [cell setLayoutMargins:UIEdgeInsetsZero]; &#125;&#125; 解释说明:iOS7，想要设置cell的分割线显示到最左端，只需要设置separatorInset的值为UIEdgeInsetsZero。 iOS8，简单设置separatorInset的值为UIEdgeInsetsZero的方法已经无效了。UIView的layoutMargins 默认为{8, 8, 8, 8}。 cell的preservesSuperviewLayoutMargins默认为true时，可能会导致cell被其父UITableView的LayoutMargin影响。如果设置为false时，cell不被UITableView的LayoutMargin影响。 2.全局设置方法(iOS7 8 9 通用) 123456789101112131415[[UITableView appearance] setSeparatorStyle:UITableViewCellSeparatorStyleSingleLine];[[UITableView appearance] setSeparatorInset:UIEdgeInsetsZero];[[UITableViewCell appearance] setSeparatorInset:UIEdgeInsetsZero];if ([UITableView instancesRespondToSelector:@selector(setLayoutMargins:)]) &#123;[[UITableView appearance] setLayoutMargins:UIEdgeInsetsZero];[[UITableViewCell appearance] setLayoutMargins:UIEdgeInsetsZero];[[UITableViewCell appearance] setPreservesSuperviewLayoutMargins:NO];&#125; 参考链接: 1.stackoverflow 2.http://www.cnblogs.com/Zev_Fung/p/5650922.html]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS 9 - Keyboard 出现在 UIAlertView 不消失]]></title>
    <url>%2F2016%2F10%2F01%2FUIAlertView%E4%B8%8D%E6%B6%88%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[今天遇见一个奇怪的bug,当我的UIAlertView 消失的时候键盘弹出来了,这个只出现在第一次安装的时候万能的stackoverflow上面有这个问题的一些解决方案: 1.使用新的api,UIAlertController 1234UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Alert Title!" message:@"This is an alert message." preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *ok = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:nil]; [alertController addAction:ok];[self presentViewController:alertController animated:NO completion:nil]; 2.另外一个方法就是延迟调用一下alertView. 12345@weakify(self);dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.6 *NSEC_PER_SEC)),dispatch_get_main_queue(), ^&#123; @strongify(self); [self loadUpdateAPI]; &#125;); 3.另外一种注销键盘 1[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil]; 出现的原因可能是键盘状态没有完全被收回,导致出现的 如果有更好的方案可以告诉我]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode中Link Binary With Libraries Status Required or Optional]]></title>
    <url>%2F2016%2F09%2F06%2FLink%20Binary%20With%2F</url>
    <content type="text"><![CDATA[Xcode中Link Binary With Libraries Status Required or OptionalLibraries and frameworks are designated as Required by default, but you can change this designation to Optional. Required libraries must be present on the host computer for the product to load. Optional libraries do not have to be present for the product to load. A Required framework will always be loaded into memory, but an Optional framework will be loaded only if needed. The initial load of the application will be faster if a large library that is never needed is designated as Optional. 内容:在指定设备上根据系统版本选择加载framework 状态,否则会出现崩溃.常见 &lt;NotficationCenter.framework&gt;需要 Optional,否则会在低版本系统ios7下崩溃.]]></content>
      <categories>
        <category>ios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cocopod工作原理分析]]></title>
    <url>%2F2016%2F08%2F27%2Fcocopod%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Cocoapods 的工作流程pod install 执行流程可分为如下五个步骤:1.查看 ~/.cocoapods/repo/master/Specs 是否存在; 2.存在，从这个本地三方库信息库中获取 Podfile 中对应三方库的 git 地址; 3.不存在，输出 Setting up CocoaPods Master repo，并拉取三方库信息库到 ~/.cocoapods/repo/中.Master repo地址; 4.使用 git 命令从 GitHub 上拉取 Podfile 中对应的三方库源码; cd 进了 Alamofire 文件夹,里面都是release 版本号,当我们使用 pod search Alamofire 命令时会将这里的所有版本号输出出来。到最新版本号里面是一个 Alamofire.podspec.json 文件,可以看到这里包含了所有的三方库的相关信息，包括名字，协议，描述，Github 地址，支持平台等。 12345678910111213141516171819202122&#123;"name": "Alamofire", "version": "4.0.0", "license": "MIT", "summary": "Elegant HTTP Networking in Swift", "homepage": "https://github.com/Alamofire/Alamofire", "social_media_url": "http://twitter.com/AlamofireSF", "authors": &#123; "Alamofire Software Foundation": "info@alamofire.org" &#125;, "source": &#123; "git": "https://github.com/Alamofire/Alamofire.git", "tag": "4.0.0" &#125;, "platforms": &#123; "ios": "8.0", "osx": "10.9", "tvos": "9.0", "watchos": "2.0" &#125;, "source_files": "Source/*.swift"&#125; 在查找到对应文件夹后，进行 json 数据解析，获得三方库的 repo 地址，调用本地 git 命令拉取源码，拉取完成后调用本地 xcodebuild 命令把三方库编译为 Framework。 pod setup 设置pod仓库,执行流程可分为如下步骤:1.判断 ~/.cocoapods/repo目录是否存在 2.存在，依次调用 set_master_repo_url，set_master_repo_branch，update_master_repo 三个函数分别设置 repo 主分支地址，git checkout 到主分支，拉取主分支代码，更新repo 3.不存在，添加主分支 repo Podfile.lock这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。 使用技巧1.若 Podfile 中指定 Alamofire 的版本号为 4.2.0,但本地 ~/cocoapods/repo/master/Specs/Alamofire 中并没有此版本号，此时使用 pod install –no-repo-update 会出现错误;2.我们便可以手动在 ~./cocoapods/repo/master/Specs 中添加我们需要的三方库版本信息，避免了把所有的并没有使用到的三方库信息更新到本地。3.这样可以避免更新的内容过大就会,等待很久。 原理和说明1、第三方库会被编译成.a静态库供我们真正的工程使用。CocoaPods会将所有的第三方库以target的方式组成一个名为Pods的工程，该工程就放在刚才新生成的Pods目录下。整个第三方库工程会生成一个名称为libPods.a的静态库提供给我们自己的CocoaPodsTest工程使用。对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中 2、CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依赖和参数,tagert配置文件]]></content>
      <categories>
        <category>原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS CocoaPods安装使用错误记录]]></title>
    <url>%2F2016%2F08%2F02%2FCocoaPods%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1.gem install cocoapods12ERROR: While executing gem ... (Errno::EPERM)Operation not permitted - /usr/bin/pod 用下面命名安装 1sudo gem install -n /usr/local/bin cocoapods 2.更换更新数据源国内镜像,每天都更新code.net123pod repo remove masterpod repo add master https://git.coding.net/CocoaPods/Specs.git pod setup 安装自己的私有仓库pod 1pod repo add sdkMaster https://gitlab.coding.net/Specs.git 3.常用更新安装命名,不进行本地库更新更新pod pod update --verbose --no-repo-update 安装pod命令 pod install --verbose --no-repo-update 4.安装和卸载pod12sudo gem uninstall cocoapods 卸载sudo gem install cocoapods 指定版本追加(-v 0.39) 安装 5.pod错误错误描述cocoapods: Failed to connect to GitHub to update the CocoaPods/Specs specs repo 更新pod和ruby 123brew install ruby //安装brew upgrade ruby //更新sudo gem install cocoapods stackoverflow]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom+Nuclide开发工具(React Native)]]></title>
    <url>%2F2016%2F07%2F27%2FAtom%2BNuclide%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装环境1.安装atom https://atom.io/,下载最新版本.2.Nuclide常规安装Nuclide项目官方地址:https://github.com/facebook/nuclide 点击Atom-&gt;Preferences打开Setting,然后点击install，输入nuclide搜索，进行下载即可 上面安装方式比较慢,更推荐源码安装: 1234git clone https://github.com/facebook/nuclide.gitcd nuclidenpm installapm link 3.Nuclide常规配置1.搜索“nuclide”，点击“Settings”选中:intall recommmended packages on startup关闭 Atom ,重新打开. 2.安装watchman 和 flow123brew install watchmanbrew install flownpm install fbjs 如果安装过，可以更新一下 12brew upgrade watchmanbrew upgrade flow 3.常用插件禁用自带的nuclide-format-js 下载格式化https://atom.io/packages/atom-beautifyjsx里面开启 消除atom 中间的线设置里面的atom-&gt;stylesheet添加下面代码 123atom-text-editor::shadow .wrap-guide &#123; visibility: hidden;&#125; 4.针对不同电脑设置之间的设置同步安装package sync-settings:,按说明操作同步命令 12sync-settings:backupsync-settings:restore 5.Atom 编辑器快捷键快捷键大全 参考1 参考2]]></content>
      <categories>
        <category>BFE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[autojum和zsh使用MAC]]></title>
    <url>%2F2016%2F07%2F27%2Fautojump%E5%92%8Czsh%E4%BD%BF%E7%94%A8MAC%2F</url>
    <content type="text"><![CDATA[安装oh my zsh环境1.安装wget http://ftp.gnu.org/gnu/wget/,下载最新版本.2.解压缩,cd到目录文件夹,依次执行命令123./configure --with-ssl=opensslmakesudo make install 备注:出现错误 1checking host system type... configure: error: can not guess host type; you must specify one 执行下面的命令 1./configure --with-ssl=openssl --host=TARGET 3.自动安装1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 或者手动安装 12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 成功后退出页面重新打开终端. 备注:如果没有变化可以执行切换 1zsh 配置文件在~/.zshrc里面 4.切换shell用如下命令切换shell: 1chsh -s /bin/zsh 重启terminal就好啦，应该就成功的从bash切换到zsh了:) 查看当前使用的shell 1echo $SHELL 如果你想看看自己的机子上装了哪些shell，可以使用如下命令： 1cat /etc/shells 插件1.安装autojump执行命令自动安装1brew install autojump 或者手动安装 1wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz 解压后进入目录,执行 1./install.sh 最后把以下代码加入~/.zshrc： 1[[ -s `brew --prefix`/etc/autojump.sh ]] &amp;&amp; . `brew --prefix`/etc/autojump.sh 同时追加 1plugins=(git autojump osx) 使用是 1j xxx文件夹 2.git plugin 配置快捷配置,1source ~/.oh-my-zsh/plugins/git/git.plugin.zsh 自定义设置对RN的命名简化,在~/.zshrc里面最后添加 12alias rna="react-native run-android"alias rni="react-native run-ios" 以后就可以使用rna `rni `运行了 显示隐藏文件的方法1234567#显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool trueosascript -e 'tell application "Finder" to quit'#不显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool falseosascript -e 'tell application "Finder" to quit' 安装ruby通过Homebrew安装Ruby 1$ brew install ruby 错误log 1Users/yangshuo06/.rvm/src/ruby-2.4.1/.ext/x86_64-darwin17/openssl.bundle, 9): Library not loaded: /usr/local/opt/openssl@1.1/lib/libssl.1.1.dylib (LoadError) 全部删掉重新安装 12345brew uninstall rubybrew uninstall openssluninstall_oh_my_zsh //卸载oh_my_zsh /usr/local/opt 权限问题 1sudo chown -R `whoami`:admin /usr/local/opt 参考1 参考2 Ruby安装(Mac)]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git使用技巧]]></title>
    <url>%2F2016%2F07%2F20%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[常用命令ssh-key的作用我们使用ssh登录服务器时，一般常见的会使用用户名/密码方式登录，也可以使用ssh key实行免密码登录，一般现在这种方式被Git服务器使用的比较多。 解决本地多个ssh-key的配置1.生成不同的密钥,ssh会根据登陆不同的域来读取相应的私钥文件 12ssh-keygen -t rsa -f ~/.ssh/id_rsa.work -C "Key for Work" ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C "Key for GitHub" 在 ~/.ssh/config 目录内修改文件config 12345678Host *.workdomain.com IdentityFile ~/.ssh/id_rsa.work User lee Host github.com IdentityFile ~/.ssh/id_rsa.github User git 用下面的命令测试一下 1ssh -T git@github.com 返回成功 1Hi sukeyang! You've successfully authenticated, but GitHub does not provide shell access. 1.提示 WARNING: UNPROTECTED PRIVATE KEY FILE! 123456@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for '/Users/yangshuo/.ssh/winid_rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored. 解决办法：在命令行输入chmod 700 id_rsa.github即可。这里“id_rsa.githu”就是warning里给出的密钥文件名。 2.报错No submodule mapping found in .gitmodules for path; 12git submodule statusgit rm --cached Classes/lib/AFKissXMLRequestOperation 查看状态,Classes/lib/AFKissXMLRequestOperation为要删除的路径,然后就oK了. 3.多帐号github配置生成第二个ssh key,并按上面的方法进行测试 1ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C "Key for GitHub" 修改在.ssh/下创建config文件 内容如下： 1234567Host github.com HostName github.com IdentityFile ~/.ssh/id_rsa Host my.github.com HostName github.com IdentityFile ~/.ssh/my 进行验证 1ssh -T git@my.github.com 打开.Git/config文件,修改下面url地址就可以了 1234#更改[remote "origin"]项中的url中的 #my.github.com 对应上面配置的host [remote "origin"] url = git@my.github.com:itmyline/blog.git 错误收集1.ssh “permissions are too open” errorKeys need to be only readable by you: 1chmod 400 ~/.ssh/id_rsa stack]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[升级iOS10后，部分App更新之后无法联网怎么办？]]></title>
    <url>%2F2016%2F07%2F03%2F%E9%83%A8%E5%88%86App%E6%9B%B4%E6%96%B0%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[苹果在iOS10中，增加了“使用无线局域网与蜂窝移动应用”的功能。有些App升级后默认关闭了数据使用，导致无法联网 方法1:进入“设置-&gt;蜂窝移动网络-&gt;使用无线局域网与蜂窝移动的应用”（或者“设置-&gt;无线局域网-&gt;使用无线局域网与蜂窝移动的应用”），找到无法联网的App，允许其“使用数据”即可。 方法2:另外还有一种Bug情况：在该列表中找不到这款无法联网的App。 此时，在列表中任意选择一个App，先关闭“无线局域网与蜂窝移动数据“，即不允许其使用数据。然后再重新打开允许使用“无线局域网与蜂窝移动数据”。 返回桌面，再次打开刚才无法联网的App，这时候系统会提示“是否允许App使用数据网络”，点击“允许”，App即可顺利联网使用。 方法3:重启手机,进入app,会进行提示!]]></content>
      <categories>
        <category>iphone</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo 搭建博客总结(二)]]></title>
    <url>%2F2016%2F06%2F07%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2%2F</url>
    <content type="text"><![CDATA[1.创建分类建立分类文件夹 hexo new page categories xxx.md 头部写成这样 title: GitHub + Hexo 搭建博客总结(二) date: 2017-02-07 17:34:35 tags: categories: tools 2.底部统计安装脚本（必选）,参考链接打开themes/你的主题/layout/_partial/footer.pejs添加如下脚本即可。 &lt;script async src=&quot;https://dn-lbstatics.qbox.me/ busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt; &lt;/script&gt; 3.为Hexo 添加 Swiftype 站内搜索1.去 Swiftype官网注册好账号，然后点击 Create Engine，输入网址并填好名称，配置好后 Swiftype 会自动开始抓取网站数据，点击 Manage 下面的 Content ，就能看到抓取到的网站数据。2.打开 Hexo 主题配置，以 jacman 为例，打开 jacman 目录下的 _config.yml 文件，在末尾添加 swift_search: ## https://swiftype.com/ enable: true id: ## 这里填写前面记下的 Swiftype id 3.替换文件,在到 jacman\layout\/_partial 目录，打开 header.ejs 这个文件 12345&lt;% &#125; else if(theme.baidu_search.enable)&#123; %&gt;&lt;form class="search" action="&lt;%- theme.baidu_search.site %&gt;" target="_blank"&gt;&lt;label&gt;Search&lt;/label&gt;&lt;input name="s" type="hidden" value= &lt;%= theme.baidu_search.id %&gt; &gt;&lt;input type="text" name="q" size="30" placeholder="&lt;%= __('search') %&gt;"&gt;&lt;br&gt;&lt;/form&gt; 在这段代码后边添加 12345&lt;% &#125; else if(theme.swift_search.enable)&#123; %&gt;&lt;form class="search" action="&lt;%- config.root %&gt;search/index.html" method="get" accept-charset="utf-8"&gt;&lt;label&gt;Search&lt;/label&gt;&lt;input type="text" id="search" class="st-default-search-input" maxlength="20" placeholder="Search" /&gt;&lt;/form&gt; 最后在文件最后一个前添加 1234567&lt;script type="text/javascript"&gt;(function(w,d,t,u,n,s,e)&#123;w['SwiftypeObject']=n;w[n]=w[n]||function()&#123;(w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t);e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);&#125;)(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');_st('install','Zo1mzEpQeR6Xjr3hz4jd','2.0.0');&lt;/script&gt; 4.图片处理用七牛为 Hexo 存储图片链接 5.开启统计hexo安装统计插件,链接 6.首页文章展示摘要该主题首页文章列表默认是全部展开，感觉不好，我关闭掉了，只展示少量摘要。修改\themes\jacman下面_config.yml中的expand改成false即可 123index: expand: false ## default is unexpanding,so you can only see the short description of each post. excerpt_link: Read More 7.配置模板文章我们可以修改根目录下\scaffolds\post.md文件，配置好基本的信息，比如： 1234title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: tools 8.代码显示不全等问题用下面方式避免,官网说明,链接 123&#123;% codeblock lang:objc %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125; 9.编写脚本执行的命令-bash: hexo: command not found解决办法,编写shell 脚本,执行下面命令,自动部署,确保路径正确; 123/usr/local/bin/node /usr/local/lib/node_modules/hexo-cli/bin/hexo clean;/usr/local/bin/node /usr/local/lib/node_modules/hexo-cli/bin/hexo g; /usr/local/bin/node /usr/local/lib/node_modules/hexo-cli/bin/hexo d;]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo 搭建博客总结(一)]]></title>
    <url>%2F2016%2F06%2F04%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装配置环境1.安装Node.js,Nodejs官网，更换为淘宝的npm源 1npm install cnpm -g --registry=https://registry.npm.taobao.org 注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm） 2.安装hexo 1234#安装sudo npm install hexo-cli -g#升级npm update hexo -g 3.初始化Hexo hexo init 4.安装依赖 npm install npm install hexo-server --save #服务器 5.启动Hexo hexo server 或者简写 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 然后浏览器输入 http://localhost:4000 你会看到Hexo的示例页面. 6.配置github,创建代码仓库,这个仓库的名字需要和你的账号对应。格式: yourname.github.io ,然后 https://yourname.github.io ,就是部署的网页地址Generating a new SSH key7.config 的一些配置 Plugins: #插件 - hexo-generator-feed - hexo-generator-sitemap #Feed Atom feed: type: atom path: atom.xml limit: 20 #sitemap sitemap: path: sitemap.xml theme: jacman #主题更换themes/ # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/410900345/410900345.github.io.git #github仓库地址 branch: master # github分支 格式要比上一行多两个空格,才能正确8.jacman主题的使用,传送门,在jacman/_config.yml里面设置,评论 comments填写duoshuo_shortname多说的用户名，启用多说评论系统。 使用Hexo1.新建文章 hexo new &quot;test&quot; 2.生成静态网站 hexo generate 3.hexo部署 hexo deploy 或者简写 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 提示[info] Deploy done: git 说明部署成功,我的个人博客 4.更换主题 jacman cd hexo git clone https://github.com/wuchong/jacman.git themes/jacman 5.sitemap &amp; rss访问/atom.xml和/sitemap.xml $ npm install hexo-generator-feed --save $ npm install hexo-generator-sitemap --save $ npm install hexo-generator-baidu-sitemap --save $ hexo generate 必须执行最后一步generate才生效 常见错误1.白板和Cannot GET / 几个字,我们需要手动配置些东西，我们需要输入下面三行命令： npm install hexo-renderer-ejs --save npm install hexo-renderer-stylus --save npm install hexo-renderer-marked --save 这个时候再重新生成静态文件，命令： hexo generate （或hexo g） 启动本地服务器： hexo server （或hexo s） 2.如果在博客文章列表中，不想全文显示，可以增加 , 后面的内容就不会显示 &lt;!--more--&gt;]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
</search>
